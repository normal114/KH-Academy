<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>

<style type="text/css">

	.select {
		cursor: pointer; /* 손가락으로 변하게 하는 코드이다 */
	}
	
</style>

<script type="text/javascript">
		
	onload=function(){
		// 배열 선언 방법
		// onload는 브라우저가 로딩 된 후라는 의미이다. 따라서 브라우저를 열면 로딩이 끝난 후 바로 명령을 수행(코드를 출력)한다.
		var arrObj01 = new Array();
		var arrObj02 = ["one", "two", 3, 4];
		alert(typeof(arrObj01) + " : " + arrObj01);
		alert(typeof(arrObj02) + " : " + arrObj02);
		
		// 길이 정의 선언
		var arrObj03 = new Array(5);
		alert(arrObj03[2]); // -> 초기값(X). undefined가 출력된다. type이 안 잡혀져 있어서 에러가 나는 것이다.
		
		// 초기 값 정의되면서 선언
		var arrObj04 = new Array(1, 2, 3, 4, 5, 6, 7);
		alert(arrObj04);
		
	}

	function multiArr(){
		var len = 3;
		var arr = new Array(len);
		for (var i = 0; i < arr.length; i++) {
			arr[i] = new Array(len);
		}
		
		arr[0][0] = "딸기";
		arr[0][1] = "용과";
		arr[0][2] = "샤인머스켓";
		
		arr[1][0] = 1;
		arr[1][1] = 2;
		arr[1][2] = 3;
		
		arr[2][0] = ["test", "javascript"];
		arr[2][1] = ["java", "oracle"];
		arr[2][2] = ["ui", ["html", "css"]];
	
		// 샤인머스켓css
		alert(arr[0][2]+arr[2][2][1][1]); // 브라우저에서 다중배열 클릭하면 샤인머스켓css가 출력된다.
	}

	function joinTest(){
		var cars = ["볼보", "코닉세그 레제라", "캠핑카", "마세라티", "아우디 A8", "재규어", "티볼리", "셀토스", "bmw 미니", "qm3", "소형 suv"];
		var res = cars.join("\n"); // , 사이사이에 \n(엔터)가 전부 들어간다 ("*")도 가능하도 뭐든 가능하다.
		alert(res);
	}
	
	function sortTest01() {
		var arr = ["z", "a", "S", "d", "f", "x", "c"]; // 대문자 먼저 출력된다.
		// 아스키 코드 순 정렬
		arr.sort();
		alert(arr);
	}
	
	function sortTest02(){
		var arr = [10, 34, 1, 25, 8, 22];	
		arr.sort(compareNum);
		alert(arr);
		
	}
	
	// 크기 비교 함수
	function compareNum(a, b) { // 아스키코드의 크기순대로 정렬한다.
		/* 
		a > b  : ?
		a == b : ?
		a < b  : ?
		*/ 
		return a - b;
		return -1; // 거꾸로 정렬한다.
	}
	
	function reverseTest(){
		var arr = [19, 2, 22, 41, 33, 5];
		// arr.sort(function(a, b){return a - b;}); // 익명 함수를 바로 사용하는 것도 가능하다. 함수가 값으로 사용되었다. 함수 리터럴이다.  
		arr.sort(campareNum); // 크기 순서대로 정렬한다. 
		arr.reverse(); // 역순으로 출력한다.
		alert(arr);
	}
	
	function pushAndShift(){
		var queue = new Array();
		
		queue.push("first");
		queue.push("second");
		queue.push("third");
		alert(queue);
		
		// 배열의 앞에서 잘라내기
		var a = queue.shift(); // shift 잘라내서 가지고 간다. 땡겨진다.(첫 번지 0이 계속 바뀐다.) queue 방식(먼저 들어간 것이 먼저 나오는 방식)이다.
		alert(a);
		alert(queue);
	
		queue.push(4); // push는 넣는 것이다. 배열이 계속 더해진다.  
		queue.push(5);
		
		// 배열의 뒤에서 잘라내기 (마지막 번지가 계속 줄어든다.)
		var b = queue.pop(); // popdms 뒤에서 잘라내는 것이다. stack 방식(나중에 들어간 값이 먼저 나오는 방식)이다.
		alert(b);
		alert(queue);
	}
	
	function sliceTest(){
		var array01 = new Array(1, 2, 3, 4, 5, 6, 7);
		var slice01 = array01.slice(1, 3); 
		// index 1부터 index 3의 '전'까지이다. 따라서 값 2와 3을 출력한다.
		alert(slice01);
		
		var array02 = new Array(4);
		array02[0] = new Array(1, 2);
		array02[1] = new Array(3, 4);
		array02[2] = new Array(5, 6);
		array02[3] = new Array(7, 8);
		
		var slice02 = array02.slice(1, 3); 
		// index 1은 [1, 2] index 1은 [3, 4] index 2는 [5, 6] index 4는 [7, 8]이다.
		// index 1~3 이전, 즉 index 2까지이니 [3, 4]+[5, 6]이니 3, 4, 5, 6이 출력된다.
		
		alert(slice02);
		// *****slice에서 잘라온 배열은 원본배열이랑 연관되어 있다. 즉 slice02는 array02랑 연관되어 있다.
		// 따라서 slice02값을 바꾸어도 array02의 배열 값이 바뀌게 된다.
		// Java로 예를 들면 깊은 값 복사가 아니고 얉은 값 복사가 된 것이다.
		slice02[0][1] = 40;
		alert(array02);
	}
	
	
</script>
	
</head>
<body>

	<h1>배열 객체</h1>
	
	<ul>
		<li onclick="multiArr();" class="select">다중 배열</li>
		<li onclick="joinTest();" class="select">join 함수</li>
		<li>
			배열 정렬
			<ul>
				<li onclick="sortTest01();" class="select">문자 정렬</li>
				<li onclick="sortTest02();" class="select">숫자 정렬</li>
				<li onclick="reverseTest();" class="select">역순 정렬</li>
			</ul>
		</li>
		<li onclick="pushAndShift();" class="select">
			배열 저장방식
			<ul>
				<li>push()</li>
				<li>shift()</li>
				<li>pop()</li>
			</ul>
		</li>
		<li onclick="sliceTest()" class="select">slice()</li>
	</ul>
	
</body>
</html>